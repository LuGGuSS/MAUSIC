using MAUSIC.Data.Constants;
using MAUSIC.Data.Entities;
using MAUSIC.Services;

namespace MAUSIC.Managers;

public class RecommendationManager
{
    private readonly RecommendationService _recommendationService;
    private readonly SongsManager _songsManager;

    public RecommendationManager(
        RecommendationService recommendationService,
        SongsManager songsManager)
    {
        _recommendationService = recommendationService;
        _songsManager = songsManager;
    }

    public async Task<List<SongEntity>> GetRecommendation(List<SongEntity> queue, int count)
    {
        var existingPairs = await _recommendationService.GetAllRecommendationPairs();

        var possiblePairs = new List<RecommendationPairEntity>();

        foreach (var queuedSong in queue)
        {
            var pairs = existingPairs.Where((pair) => pair.FirstSongId == queuedSong.Id || pair.SecondSongId == queuedSong.Id);

            foreach (var pair in pairs)
            {
                // NOTE: skip if queue contains both songs
                if (pair == null
                    || (queue.Any(entity => pair.FirstSongId == entity.Id)
                        && queue.Any(entity => pair.SecondSongId == entity.Id)))
                {
                    continue;
                }

                possiblePairs.Add(pair);
            }
        }

        var result = new List<SongEntity>();

        if (possiblePairs.Count > count)
        {
            possiblePairs = TrimRecommendationPairEntities(possiblePairs, count);
        }

        foreach (var pair in possiblePairs)
        {
            var song = queue.Any(entity => entity.Id == pair.FirstSongId) ?
                await _songsManager.GetSongFromId(pair.SecondSongId) :
                await _songsManager.GetSongFromId(pair.FirstSongId);

            if (song != null)
            {
                result.Add(song);
            }
        }

        return result;
    }

    public async Task<int> TryCreateRecommendationPairs(List<SongEntity> songEntities)
    {
        var newPairs = new List<RecommendationPairEntity>();

        for (int i = 0; i < songEntities.Count; i++)
        {
            for (int j = i + 1; j < songEntities.Count; j++)
            {
                var pairEntity = new RecommendationPairEntity()
                {
                    FirstSongId = songEntities[i].Id,
                    SecondSongId = songEntities[j].Id,
                    AlgorithmWeight = CalculateWight(songEntities[i], songEntities[j]),
                    UserWeight = RecommendationConstants.DefaultWeight
                };

                newPairs.Add(pairEntity);
            }
        }

        var existingPairs = await _recommendationService.GetAllRecommendationPairs();

        int result = 0;

        if (existingPairs.Count == 0)
        {
            result = await _recommendationService.AddRecommendationPairs(newPairs);

            return result;
        }

        var songs = await _songsManager.GetAllSongs();

        foreach (var song in songEntities)
        {
            songs.Remove(song);
        }

        for (int i = 0; i < songs.Count; i++)
        {
            foreach (var songEntity in songEntities)
            {
                var pairEntity = new RecommendationPairEntity()
                {
                    FirstSongId = songs[i].Id,
                    SecondSongId = songEntity.Id,
                    AlgorithmWeight = CalculateWight(songEntity, songs[i]),
                    UserWeight = RecommendationConstants.DefaultWeight
                };

                newPairs.Add(pairEntity);
            }
        }

        result = await _recommendationService.AddRecommendationPairs(newPairs);

        return result;
    }

    private float CalculateWight(SongEntity firstSongEntity, SongEntity secondSongEntity)
    {
        var wight = RecommendationConstants.DefaultWeight;

        if (firstSongEntity.Artist == secondSongEntity.Artist)
        {
            wight += RecommendationConstants.AutoGeneratedWeight;
        }

        if (firstSongEntity.Album == secondSongEntity.Album)
        {
            wight += RecommendationConstants.AutoGeneratedWeight;
        }

        try
        {
            if ((firstSongEntity.Genres != null && secondSongEntity.Genres != null) &&
                firstSongEntity.Genres.Split(';').ToHashSet().Overlaps(secondSongEntity.Genres.Split(';')))
            {
                wight += RecommendationConstants.AutoGeneratedWeight;
            }

            if ((firstSongEntity.BPM != 0 && secondSongEntity.BPM != 0) &&
                Math.Abs((int)firstSongEntity.BPM - secondSongEntity.BPM) <= 20)
            {
                wight += RecommendationConstants.AutoGeneratedWeight;
            }

            if ((firstSongEntity.Performers != null && secondSongEntity.Performers != null) &&
                firstSongEntity.Performers.Split(';').ToHashSet().Overlaps(secondSongEntity.Performers.Split(';')))
            {
                wight += RecommendationConstants.AutoGeneratedWeight;
            }
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            throw;
        }

        return wight;
    }

    private List<RecommendationPairEntity> TrimRecommendationPairEntities(
        List<RecommendationPairEntity> pairEntities,
        int count)
    {
        var dictionary = new Dictionary<int, float>();

        pairEntities.ForEach(model =>
        {
            float normalizedSum = (model.AlgorithmWeight * 0.8f + model.UserWeight * 1.2f) / 2;

            if (normalizedSum >= 0.4f)
            {
                dictionary[model.Id] = normalizedSum;
            }
        });

        dictionary = dictionary.OrderByDescending(pair => pair.Value).ToDictionary();

        return dictionary.Select((pair) => pairEntities.First((entity) => entity.Id == pair.Key)).Take(count).ToList();
    }
}